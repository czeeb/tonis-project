{
    "docs": [
        {
            "location": "/",
            "text": "What is Tonis?\n\n\nTonis is a PSR-7 micro-framework that can also be used as MVC middleware. Tonis was built for flexibility and performance\nwhile still having the modularity of larger frameworks. Tonis features an event-driven architecture that allows you to \neasily customize the entire life-cycle for micro-services, apis, or even full on sites.\n\n\nTonis is built with best practices in mind and features 100% unit test coverage, integration tests, and high quality code.\nNo pull request will ever be merged that violates any of these standards.\n\n\nThe Name\n\n\nKyle originally got into programming by writing scripts for a game called Gemstone III (now Gemstone IV). The name comes \nfrom Tonis in Gemstone's world of of Elanthia. Tonis is the messenger of the gods and is renowned for his speed.\n\n\nFeatures\n\n\nTonis includes the following features out of the box:\n\n\n\n\nMultiple view engine support - includes Twig, Plates, and JSON out of the box.\n\n\nSingle purpose actions vs controllers\n\n\nError Handling\n\n\nDependency Injection\n\n\nMiddleware support\n\n\nPSR-7 compliant\n\n\nPackage (reusable chunks of code) management\n\n\n100% test coverage on all components\n\n\nHigh quality (9.5+ on Scrutiniizer) components\n\n\n\n\nAdditionally, the following core packages are available:\n\n\n\n\nAsset management\n\n\nDoctrine ORM",
            "title": "Home"
        },
        {
            "location": "/#what-is-tonis",
            "text": "Tonis is a PSR-7 micro-framework that can also be used as MVC middleware. Tonis was built for flexibility and performance\nwhile still having the modularity of larger frameworks. Tonis features an event-driven architecture that allows you to \neasily customize the entire life-cycle for micro-services, apis, or even full on sites.  Tonis is built with best practices in mind and features 100% unit test coverage, integration tests, and high quality code.\nNo pull request will ever be merged that violates any of these standards.",
            "title": "What is Tonis?"
        },
        {
            "location": "/#the-name",
            "text": "Kyle originally got into programming by writing scripts for a game called Gemstone III (now Gemstone IV). The name comes \nfrom Tonis in Gemstone's world of of Elanthia. Tonis is the messenger of the gods and is renowned for his speed.",
            "title": "The Name"
        },
        {
            "location": "/#features",
            "text": "Tonis includes the following features out of the box:   Multiple view engine support - includes Twig, Plates, and JSON out of the box.  Single purpose actions vs controllers  Error Handling  Dependency Injection  Middleware support  PSR-7 compliant  Package (reusable chunks of code) management  100% test coverage on all components  High quality (9.5+ on Scrutiniizer) components   Additionally, the following core packages are available:   Asset management  Doctrine ORM",
            "title": "Features"
        },
        {
            "location": "/getting-started/installation/",
            "text": "Installation\n\n\nTonis uses \nComposer\n to manage dependencies and is required. Once composer is \ninstalled you can install Tonis using the following command:\n\n\nAs a Micro-Framework\n\n\nTo use Tonis as micro-framework you need to add \ntonis/tonis\n to \ncomposer.json\n.\n\n\ncomposer init\ncomposer require tonis/tonis\n\n\n\n\nOnce complete you use the following \nindex.php\n to get started.\n\n\n?php\nrequire __DIR__ . '/vendor/autoload.php';\n\n$tonis = (new \\Tonis\\Mvc\\Factory\\TonisFactory)-\ncreateWeb();\n$routes = $tonis-\nroutes();\n\n$routes-\nget('/hello/{name}', function ($name) {\n    return 'Hello ' . $name;\n});\n\necho $tonis-\nrun()-\ngetBody();\n\n\n\n\nAs Middleware\n\n\ncomposer create-project tonis/tonis --prefer-dist\n\n\n\n\nServer Requirements\n\n\nTonis has the following requirement:\n\n\n\n\nPHP 5.5 or greater",
            "title": "Installation"
        },
        {
            "location": "/getting-started/installation/#installation",
            "text": "Tonis uses  Composer  to manage dependencies and is required. Once composer is \ninstalled you can install Tonis using the following command:",
            "title": "Installation"
        },
        {
            "location": "/getting-started/installation/#as-a-micro-framework",
            "text": "To use Tonis as micro-framework you need to add  tonis/tonis  to  composer.json .  composer init\ncomposer require tonis/tonis  Once complete you use the following  index.php  to get started.  ?php\nrequire __DIR__ . '/vendor/autoload.php';\n\n$tonis = (new \\Tonis\\Mvc\\Factory\\TonisFactory)- createWeb();\n$routes = $tonis- routes();\n\n$routes- get('/hello/{name}', function ($name) {\n    return 'Hello ' . $name;\n});\n\necho $tonis- run()- getBody();",
            "title": "As a Micro-Framework"
        },
        {
            "location": "/getting-started/installation/#as-middleware",
            "text": "composer create-project tonis/tonis --prefer-dist",
            "title": "As Middleware"
        },
        {
            "location": "/getting-started/installation/#server-requirements",
            "text": "Tonis has the following requirement:   PHP 5.5 or greater",
            "title": "Server Requirements"
        },
        {
            "location": "/basics/actions/",
            "text": "Actions",
            "title": "Actions"
        },
        {
            "location": "/basics/actions/#actions",
            "text": "",
            "title": "Actions"
        },
        {
            "location": "/basics/routing/",
            "text": "Routing (Tonis\\Router)\n\n\nYou define routes by using the \nTonis\\Router\\RouteCollection\n available to Tonis. Additionally, packages may\nuse the \nconfigureRoutes()\n method to define their routes.\n\n\nBasic Routes\n\n\nThe route collection featuers convenience methods which map directly to HTTP methods. \n\n\n$routes-\nget('/', function () {\n    return 'Hey Tonis';\n});\n\n$routes-\npost('/', function () {\n    //\n});\n\n$routes-\npatch('/', function () {\n    //\n});\n\n$routes-\nput('/', function () {\n    //\n});\n\n$routes-\ndelete('/', function () {\n    //\n});\n\n\n\n\nRoute Parameters\n\n\n// required name parameter - matches /hello/tonis\n$routes-\nget('/hello/{name}', ...);\n\n// optional name parameter - matches /hello or /hello/tonis\n$routes-\nget('/hello{/name?}', ...);\n\n\n\n\nIt's important to note the \"/\" inside the \"{\". If you leave this outside the curl brace it is not optional and will\nbe required for the route to match!\n\n\n// parameter constraints - matches /hello/tonis but not /hello/1234\n$routes-\nget('/hello/{name:\\w+}', ...);\n\n// the kitchen sink (id is required as a digit, name is optional and matches a-z and A-Z\n// matches /hello/1 or /hello/1-tonis\n$routes-\nget('/hello/{id:\\d+}{-name?:[a-zA-Z]+}');\n\n\n\n\nAssembling URLs\n\n\nIn order to assemble a route you must have given it a name.\n\n\n$routes-\nget('/', function () {}, 'name');\n\n\n\n\nTo generate a url from a route you may use the \nassemble()\n method on the \nRouteCollection\n.\n\n\n$routes-\nassemble('name')",
            "title": "Routing"
        },
        {
            "location": "/basics/routing/#routing-tonisrouter",
            "text": "You define routes by using the  Tonis\\Router\\RouteCollection  available to Tonis. Additionally, packages may\nuse the  configureRoutes()  method to define their routes.",
            "title": "Routing (Tonis\\Router)"
        },
        {
            "location": "/basics/routing/#basic-routes",
            "text": "The route collection featuers convenience methods which map directly to HTTP methods.   $routes- get('/', function () {\n    return 'Hey Tonis';\n});\n\n$routes- post('/', function () {\n    //\n});\n\n$routes- patch('/', function () {\n    //\n});\n\n$routes- put('/', function () {\n    //\n});\n\n$routes- delete('/', function () {\n    //\n});",
            "title": "Basic Routes"
        },
        {
            "location": "/basics/routing/#route-parameters",
            "text": "// required name parameter - matches /hello/tonis\n$routes- get('/hello/{name}', ...);\n\n// optional name parameter - matches /hello or /hello/tonis\n$routes- get('/hello{/name?}', ...);  It's important to note the \"/\" inside the \"{\". If you leave this outside the curl brace it is not optional and will\nbe required for the route to match!  // parameter constraints - matches /hello/tonis but not /hello/1234\n$routes- get('/hello/{name:\\w+}', ...);\n\n// the kitchen sink (id is required as a digit, name is optional and matches a-z and A-Z\n// matches /hello/1 or /hello/1-tonis\n$routes- get('/hello/{id:\\d+}{-name?:[a-zA-Z]+}');",
            "title": "Route Parameters"
        },
        {
            "location": "/basics/routing/#assembling-urls",
            "text": "In order to assemble a route you must have given it a name.  $routes- get('/', function () {}, 'name');  To generate a url from a route you may use the  assemble()  method on the  RouteCollection .  $routes- assemble('name')",
            "title": "Assembling URLs"
        },
        {
            "location": "/basics/services/",
            "text": "Service Container (Tonis\\Di)\n\n\nTonis features a light-weight and simple dependency injection container to help with inversion of control. You can \nread more about inversion of control on \nMartin Fowler's site\n.\n\n\nFeatures\n\n\n\n\nParameter management\n\n\nSimple API\n\n\nService decoration.\n\n\nRecursion detection.\n\n\n\n\nParameters\n\n\nYou can assign parameters to the container using array notation. All parameters are available later to setup your \nother services.\n\n\n$di['foo'] = 'bar';\n$di['debug'] = false;\n\n\n\n\nServices\n\n\nYou can define your services using the following:\n\n\n\n\nPassing a string of the fully qualified class name\n\n\nPassing the created object\n\n\nPassing an instance of \nTonis\\Di\\ServiceFactoryInterface\n\n\nUsing any callable\n\n\nAny combination of the above\n\n\n\n\nSetting Services\n\n\n// using the fqcn\n$di-\nset('stdclass', 'StdClass');\n\n// setting the object directly\n$di-\nset('stdclass', new StdClass);\n\n// using a callable\n$di-\nset('stdclass', function (\\Tonis\\Di\\Container $di) {\n    return new StdClass;\n});\n\n// using an instance of ServiceFactoryInterface\nclass StdClassFactory implements \\Tonis\\Di\\ServiceFactoryInterface\n{\n    public function createService(\\Tonis\\Di\\Container $di) {\n        return new StdClass;\n    }\n}\n\n\n\n\nCheck if a service exists\n\n\n$di-\nhas('StdClass'); // true/false\n\n\n\n\nRetrieving services\n\n\n$di-\nget('StdClass');\n\n\n\n\nSetting a raw service\n\n\nSometimes you have a callable that you want to set as a service without the container trying to resolve the callable. \nTo do this pass true as third argument to the \nset\n method.\n\n\nclass MyClass\n{\n    public function __invoke()\n    {\n        return new StdClass;\n    }\n}\n\n$di = $tonis-\ndi();\n// normally get(MyClass::class) will return StdClass\n$di-\nset(MyClass::class, MyClass::class);\n\n// now get(MyClass::class) will return an instance of MyClass instead  \n$di-\nset(MyClass::class, MyClass::class, true);\n\n\n\n\nDecorating Services\n\n\nTonis features powerful service decoration which let's you modify your service configuration at run-time. This is\nvery powerful when coupled with package management to allow customization of services.\n\n\nUsing decorate\n\n\nThe \ndecorate\n method allows you to modify the service after it has been created by the container. The \ndecorate\n method\naccepts a closure or an instance of \nTonis\\Di\\ServiceDecoratorInterface\n.\n\n\n$di-\nset(StdClass::class, new StdClass);\n$di-\ndecorate(StdClass::class, function (\\Tonis\\Di\\Container $di, StdClass $stdclass) {\n    $stdclass-\nfoo = 'bar';\n});\n\n\n\n\nYou could use decorators to conditionally modify debug settings at run-time or setup logging, caching, etc. based on \nthe environment. This is especially useful when third-party packages don't provide a way to configure their services\nthrough configuration.\n\n\nUsing wrap\n\n\nwrap\n is similar to \ndecorate\n but more powerful and allows you to completely replace the service if you wish. \n\n\nclass Dog\n{\n    private $sleep = false;\n    public function speak() { echo $this-\nsleep ? '' : 'Woof!'; }\n    public function sleep() { $this-\nsleep = true; }\n}\n\nclass MyDog\n{\n    public function __construct(Dog $dog) { $this-\ndog = $dog; }\n    public function speak() { echo 'My: ' . $this-\ndog-\nspeak(); }\n}\n\n$di-\nset(Dog::class, Dog::class);\n\n// tell the dog to sleep so it doesn't speak\n$di-\nwrap(Dog::class, function (\\Tonis\\Di\\Container $di, $serviceName, $callable) {\n    $dog = $callable();\n    $dog-\nsleep();\n\n    return $dog;\n});\n\n// I want to use my own dog not the dog the neighbor (package) has\n$di-\nwrap(Dog::class, function (\\Tonis\\Di\\Container $di, $serviceName, $callable) {\n    return new MyDog($callable());\n});\n\n\n\n\nA good use-case for wrap is modifying the service definitions provided by third-party packages. For example, if there\nis a particularly heavy service you could wrap it in a Lazy Proxy to delay the execution until required.\n\n\nBest Practices\n\n\nWhen creating your services you generally want to avoid injecting the container directly into your services. There are \nsituations where this can be useful but doing it too much can make maintenance and testing a nightmare. Instead,\nyou should use factories to create your services with the dependencies your service requires.\n\n\nuse Tonis\\Di\\Container;\n\n// do not do this\n$di-\nset('MyClass', function (Container $di) {\n    return new MyClass($di);\n});\n\n// do this instead\n$di-\nset('MyClass', function (Container $di) {\n    return new MyClass($di-\nget('dep1'), $di-\nget('dep2'));\n});",
            "title": "Services"
        },
        {
            "location": "/basics/services/#service-container-tonisdi",
            "text": "Tonis features a light-weight and simple dependency injection container to help with inversion of control. You can \nread more about inversion of control on  Martin Fowler's site .",
            "title": "Service Container (Tonis\\Di)"
        },
        {
            "location": "/basics/services/#features",
            "text": "Parameter management  Simple API  Service decoration.  Recursion detection.",
            "title": "Features"
        },
        {
            "location": "/basics/services/#parameters",
            "text": "You can assign parameters to the container using array notation. All parameters are available later to setup your \nother services.  $di['foo'] = 'bar';\n$di['debug'] = false;",
            "title": "Parameters"
        },
        {
            "location": "/basics/services/#services",
            "text": "You can define your services using the following:   Passing a string of the fully qualified class name  Passing the created object  Passing an instance of  Tonis\\Di\\ServiceFactoryInterface  Using any callable  Any combination of the above   Setting Services  // using the fqcn\n$di- set('stdclass', 'StdClass');\n\n// setting the object directly\n$di- set('stdclass', new StdClass);\n\n// using a callable\n$di- set('stdclass', function (\\Tonis\\Di\\Container $di) {\n    return new StdClass;\n});\n\n// using an instance of ServiceFactoryInterface\nclass StdClassFactory implements \\Tonis\\Di\\ServiceFactoryInterface\n{\n    public function createService(\\Tonis\\Di\\Container $di) {\n        return new StdClass;\n    }\n}  Check if a service exists  $di- has('StdClass'); // true/false  Retrieving services  $di- get('StdClass');",
            "title": "Services"
        },
        {
            "location": "/basics/services/#setting-a-raw-service",
            "text": "Sometimes you have a callable that you want to set as a service without the container trying to resolve the callable. \nTo do this pass true as third argument to the  set  method.  class MyClass\n{\n    public function __invoke()\n    {\n        return new StdClass;\n    }\n}\n\n$di = $tonis- di();\n// normally get(MyClass::class) will return StdClass\n$di- set(MyClass::class, MyClass::class);\n\n// now get(MyClass::class) will return an instance of MyClass instead  \n$di- set(MyClass::class, MyClass::class, true);",
            "title": "Setting a raw service"
        },
        {
            "location": "/basics/services/#decorating-services",
            "text": "Tonis features powerful service decoration which let's you modify your service configuration at run-time. This is\nvery powerful when coupled with package management to allow customization of services.  Using decorate  The  decorate  method allows you to modify the service after it has been created by the container. The  decorate  method\naccepts a closure or an instance of  Tonis\\Di\\ServiceDecoratorInterface .  $di- set(StdClass::class, new StdClass);\n$di- decorate(StdClass::class, function (\\Tonis\\Di\\Container $di, StdClass $stdclass) {\n    $stdclass- foo = 'bar';\n});  You could use decorators to conditionally modify debug settings at run-time or setup logging, caching, etc. based on \nthe environment. This is especially useful when third-party packages don't provide a way to configure their services\nthrough configuration.  Using wrap  wrap  is similar to  decorate  but more powerful and allows you to completely replace the service if you wish.   class Dog\n{\n    private $sleep = false;\n    public function speak() { echo $this- sleep ? '' : 'Woof!'; }\n    public function sleep() { $this- sleep = true; }\n}\n\nclass MyDog\n{\n    public function __construct(Dog $dog) { $this- dog = $dog; }\n    public function speak() { echo 'My: ' . $this- dog- speak(); }\n}\n\n$di- set(Dog::class, Dog::class);\n\n// tell the dog to sleep so it doesn't speak\n$di- wrap(Dog::class, function (\\Tonis\\Di\\Container $di, $serviceName, $callable) {\n    $dog = $callable();\n    $dog- sleep();\n\n    return $dog;\n});\n\n// I want to use my own dog not the dog the neighbor (package) has\n$di- wrap(Dog::class, function (\\Tonis\\Di\\Container $di, $serviceName, $callable) {\n    return new MyDog($callable());\n});  A good use-case for wrap is modifying the service definitions provided by third-party packages. For example, if there\nis a particularly heavy service you could wrap it in a Lazy Proxy to delay the execution until required.",
            "title": "Decorating Services"
        },
        {
            "location": "/basics/services/#best-practices",
            "text": "When creating your services you generally want to avoid injecting the container directly into your services. There are \nsituations where this can be useful but doing it too much can make maintenance and testing a nightmare. Instead,\nyou should use factories to create your services with the dependencies your service requires.  use Tonis\\Di\\Container;\n\n// do not do this\n$di- set('MyClass', function (Container $di) {\n    return new MyClass($di);\n});\n\n// do this instead\n$di- set('MyClass', function (Container $di) {\n    return new MyClass($di- get('dep1'), $di- get('dep2'));\n});",
            "title": "Best Practices"
        },
        {
            "location": "/basics/packages/",
            "text": "Packages (Tonis\\Package)",
            "title": "Packages"
        },
        {
            "location": "/basics/packages/#packages-tonispackage",
            "text": "",
            "title": "Packages (Tonis\\Package)"
        },
        {
            "location": "/advanced/lifecycle/",
            "text": "Request/Response Lifecycle",
            "title": "Request/Response Lifecycle"
        },
        {
            "location": "/advanced/lifecycle/#requestresponse-lifecycle",
            "text": "",
            "title": "Request/Response Lifecycle"
        },
        {
            "location": "/development/vagrant/",
            "text": "Vagrant\n\n\nTonis comes with a Vagrantfile.  Utilizing \nVagrant\n, the working directory will be synced with the virtualized environment.  You will need to have both \nVagrant\n and \nDocker\n installed.  You are responsible for running composer and bower from the host.\n\n\nsudo vagrant up --provider=docker\n\n\n\n\nSSH is not enabled, but you can still get a shell prompt in the container.\n\n\n$ sudo docker ps\nCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS                  NAMES\n45d0c5d94ee0        czeeb/tonis-docker-nginx:latest   \n/sbin/my_init\n     13 minutes ago      Up 13 minutes       0.0.0.0:8080-\n80/tcp   tonis_nginx_1433860664\n\n$ sudo docker exec -t -i tonis_nginx_1433860664 bash -l\nroot@45d0c5d94ee0:/#",
            "title": "Vagrant"
        },
        {
            "location": "/development/vagrant/#vagrant",
            "text": "Tonis comes with a Vagrantfile.  Utilizing  Vagrant , the working directory will be synced with the virtualized environment.  You will need to have both  Vagrant  and  Docker  installed.  You are responsible for running composer and bower from the host.  sudo vagrant up --provider=docker  SSH is not enabled, but you can still get a shell prompt in the container.  $ sudo docker ps\nCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS                  NAMES\n45d0c5d94ee0        czeeb/tonis-docker-nginx:latest    /sbin/my_init      13 minutes ago      Up 13 minutes       0.0.0.0:8080- 80/tcp   tonis_nginx_1433860664\n\n$ sudo docker exec -t -i tonis_nginx_1433860664 bash -l\nroot@45d0c5d94ee0:/#",
            "title": "Vagrant"
        },
        {
            "location": "/development/docker/",
            "text": "Docker\n\n\nA Dockerfile has also been included.  The difference between using Vagrant and \nDocker\n is that \nany changes made to the code after the Docker container has been created will not be reflected in the container.\n\nThe primary usage of the docker container is for production where code only changes on deployment.\n\n\nThe Dockerfile takes care of running both composer and bower when the container is built.",
            "title": "Docker"
        },
        {
            "location": "/development/docker/#docker",
            "text": "A Dockerfile has also been included.  The difference between using Vagrant and  Docker  is that \nany changes made to the code after the Docker container has been created will not be reflected in the container. \nThe primary usage of the docker container is for production where code only changes on deployment.  The Dockerfile takes care of running both composer and bower when the container is built.",
            "title": "Docker"
        },
        {
            "location": "/other/components-and-packages/",
            "text": "Components \n Packages\n\n\nThe following is a list of components and packages maintained by Tonis. All code has the following requirements:\n\n\n\n\nPHP 5.5 or higher, PHP 7, and HHVM support.\n\n\nComposer support\n\n\n100% unit test coverage\n\n\nMinimal dependencies\n\n\nPSR-1/PSR-2 and PSR-4 compliant\n\n\nHigh quality code (\n= 9 on \nScrutinizer\n)\n\n\n\n\nComponents\n\n\n\n\n\n\n\n\nComponent\n\n\nBuild Status\n\n\nCode Coverage\n\n\nCode Quality\n\n\n\n\n\n\n\n\n\n\nDi\n\n\n\n\n\n\n\n\n\n\n\n\nDispatcher\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\n\n\n\n\n\n\n\n\n\n\nMvc\n\n\n\n\n\n\n\n\n\n\n\n\nPackage\n\n\n\n\n\n\n\n\n\n\n\n\nRouter\n\n\n\n\n\n\n\n\n\n\n\n\nView\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPackages\n\n\n\n\n\n\n\n\nPackage\n\n\nBuild Status\n\n\nCode Coverage\n\n\nCode Quality\n\n\n\n\n\n\n\n\n\n\nAsset\n\n\n\n\n\n\n\n\n\n\n\n\nDoctrine\n\n\n\n\n\n\n\n\n\n\n\n\nDoctrine ORM",
            "title": "Components & Packages"
        },
        {
            "location": "/other/components-and-packages/#components-packages",
            "text": "The following is a list of components and packages maintained by Tonis. All code has the following requirements:   PHP 5.5 or higher, PHP 7, and HHVM support.  Composer support  100% unit test coverage  Minimal dependencies  PSR-1/PSR-2 and PSR-4 compliant  High quality code ( = 9 on  Scrutinizer )",
            "title": "Components &amp; Packages"
        },
        {
            "location": "/other/components-and-packages/#components",
            "text": "Component  Build Status  Code Coverage  Code Quality      Di       Dispatcher       Event       Mvc       Package       Router       View",
            "title": "Components"
        },
        {
            "location": "/other/components-and-packages/#packages",
            "text": "Package  Build Status  Code Coverage  Code Quality      Asset       Doctrine       Doctrine ORM",
            "title": "Packages"
        }
    ]
}